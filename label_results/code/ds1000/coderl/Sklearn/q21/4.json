{"trg_prediction": "from xgboost.sklearn import xgb\nfrom numpy import *\n\ndef gridsearch(x, y, train, test, score, param_grid):\n\tn_splits = len(train)\n\tcv_params = [{str(k): v for k, v in param_grid.items() if k!= 'n_splits'}]\n\tn_stop_rounds = int(score['early_stopping_rounds'])\n\t# print(n_splits, n_stop_rounds)\n\tbest = xgb.XGBRegressor(**param_grid)\n\t# best.fit(train, y)\n\tfor n_stop in range(n_stop_rounds + 1):\n\t\tbest.fit(train[n_splits:], y[n_splits:])\n\t\t# print(best.best_score_, best.best_params_)\n\t\tif best.best_score_ < n_stop * score['eval_metric']:\n\t\t\tbest = best.best\n\t\t\tn_stop_rounds = n_stop\n\t\telif best.best_score_ == n_stop * score['eval_metric']:\n\t\t\t# print('best: ', best)\n\t\t\tbreak\n\t# print(best)\n\ttest_score = best.predict(test[n_splits:])\n\t# print('test score: ', test_score, '\\n')\n\treturn test_score\n\ndef load_data():\n\tn, m = len(train), len(train[0])\n\ttrain = ([[x, y] for x, y in zip(train, train[1:])] for _ in range(n))\n\ttest = ([[x, y] for x, y in zip(test, test[1:])] for _ in range(n))\n\tparam_grid = {\n\t\t'n_splits': [1, 2, n, m], \n\t\t'eval_metric' : [mean_error, mean_precision, mean_f1, mean_s1, mean_error]\n\t}\n\treturn gridsearch(train, test, train, test, score=0, param_grid=param_grid)\n\nmean_error = lambda x: sum(y_"}