{"trg_prediction": "To achieve the same functionality as the `sub2ind` function in MATLAB, you can use the following code in Python using NumPy:\n\n```python\nimport numpy as np\n\ndef sub2ind(array_shape, rows, cols, slices):\n    \"\"\"\n    Convert subscripts to linear indices in NumPy array.\n    \n    Parameters:\n    - array_shape: shape of the array\n    - rows: row subscripts\n    - cols: column subscripts\n    - slices: slice subscripts\n    \n    Returns:\n    - linear indices corresponding to the subscripts\n    \"\"\"\n    # Get the number of dimensions\n    ndims = len(array_shape)\n    \n    # Convert subscripts to arrays\n    rows = np.array(rows)\n    cols = np.array(cols)\n    slices = np.array(slices)\n    \n    # Calculate the linear indices\n    linear_indices = rows + cols * array_shape[0] + slices * (array_shape[0] * array_shape[1])\n    \n    return linear_indices\n\n# Example usage\ndims = (3, 4, 2)\na = np.random.rand(*dims)\nindex = (1, 0, 1)\n\nlinear_index = sub2ind(dims, *index)\nprint(linear_index)\n```\n\nThis will output `13`, which corresponds to the linear index `(2, 1, 2)` in MATLAB.\n\nNote that the `sub2ind` function in MATLAB uses Fortran order, while NumPy uses C order. The code above assumes C order indexing. If you want to use Fortran order indexing, you can modify the calculation of `linear_indices` as follows:\n\n```python\nlinear_indices = slices + cols * array_shape[2] + rows * (array_shape[1] * array_shape[2])\n```\n\nI hope this helps! Let me know if you have any further questions."}